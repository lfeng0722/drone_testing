#!/usr/bin/env python3

import subprocess
import io, shutil
import argparse

import time
import socket

import rospy

def wait_for_port(port, host='localhost', timeout=5.0):
    """Wait until a port starts accepting TCP connections.
    Args:
        port (int): Port number.
        host (str): Host address on which the port should exist.
        timeout (float): In seconds. How long to wait before raising errors.
    Raises:
        TimeoutError: The port isn't accepting connection after time specified in `timeout`.
    """
    start_time = time.perf_counter()
    while True:
        try:
            with socket.create_connection((host, port), timeout=timeout):
                break
        except OSError as ex:
            time.sleep(0.01)
            if time.perf_counter() - start_time >= timeout:
                raise TimeoutError('Waited too long for the port {} on host {} to start accepting '
                                   'connections.'.format(port, host)) from ex

# Simple ROS wrapper to run mavproxy SITL
if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Process some integers.')
    parser.add_argument('--input', type=str, default='tcp:127.0.0.1:5760', help='Data input port (e.g. "tcp:127.0.0.1:5760")')
    parser.add_argument('--output', type=str, default='udp:127.0.0.1:14550', help='Data input port (e.g. "udp:127.0.0.1:14550")')
    parser.add_argument('--label', type=str, help='Print label (formatted as "[LABEL]")')
    args, unknown = parser.parse_known_args()

    # Start ROS
    rospy.init_node('mavproxy', anonymous=True)

    # Open up some proxies to make our connections easier to deal with
    run_proxy = "mavproxy.py"
    proxy1_args = ['--nowait', '--daemon', '--master=' + args.input, '--out=' + args.output]

    if not shutil.which(run_proxy):
        rospy.logerr("File not found! Check: " + str(run_proxy))
        exit(1)
    
    label = 'PROXY' if args.label is None else args.label

    if 'tcp' in args.input:
        while not rospy.is_shutdown():
            try:
                rospy.loginfo('[%s] Waiting for socket...' % label)
                wait_for_port(args.input.split(':')[-1])
                break
            except TimeoutError:
                # Port not ready, try again on next loop
                pass
            except rospy.exceptions.ROSInterruptException:
                # User shutdown
                break
            except Exception as ex:
                rospy.logerr('[%s] Fatal error: ' % ex)
                rospy.shutdown()
                break

    if not rospy.is_shutdown():
        # Open the process with all it's args, dump output and errors to the one stream
        with subprocess.Popen([run_proxy] + proxy1_args, stdout=subprocess.DEVNULL, stderr=subprocess.PIPE) as m:
            try:
                # Loop through any errors line by line of any output
                for line in io.TextIOWrapper(m.stderr, encoding="utf-8"):
                    rospy.logerr('[%s] %s' % (label, line.strip())) # Strip to get rid of trailing end of lines
            except rospy.ROSInterruptException:
                pass
